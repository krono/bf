%
% This material is distributed under the GNU General Public License Version 2.
% You may review the terms of this license at
% http://www.gnu.org/licenses/gpl-2.0.html
%
% Copyright (C) 2010, 2014, Michael Haupt <bf at haupz dot de>
%
% All rights reserved.
%
\documentclass{scrartcl}
%include polycode.fmt
\title{Implementing brainfuck in Haskell}
\author{Michael Haupt}
\begin{document}
\maketitle

\section{Introduction}

What is your way of getting your fingers dirty in a little starter project when you're learning a new programming language? I usually try to implement a brainfuck interpreter\footnote{For the easily offended, I shall henceforth abbreviate this as \emph{bf}.} and document it.

These days, I'm learning Haskell: having spent much pleasant time with dynamically typed programming languages (most prominently: Smalltalk) for some years, I wanted to learn a language that is \emph{really} different. Haskell, having looked interesting for quite a while, was the natural choice, and the book \emph{Real World Haskell} is a great tutorial.

So, without further ado, here's the \emph{bf} interpreter, bit by bit. Note that Haskell supports, out of the box, literate programming. This PDF file was, via \LaTeX, generated from a file that contains \LaTeX\ and Haskell source code side by side---that file can be used to run the interpreter or to generate documentation likewise.

\emph{Disclaimer: The code described below is that of a beginner. Very likely, nothing is optimised, and bugs may be lurking. I will happily accept suggestions for improvement addressing both code and writing.}

\section{The Interpreter}

\subsection{Importing Required Library Functions}

The first two lines of code are not really interesting, but required:

\begin{code}
import Data.Char (chr,ord)
import System.Environment (getArgs)
\end{code}

The \textit{chr} and \textit{ord} functions are required for obtaining characters' ASCII values and for turning such numeric values back into characters. Recall that Haskell is statically typed and pretty picky when it comes to implicitly using a \texttt{char} as an \texttt{int} and vice versa, like in C.

Next, \textit{getArgs} will be important since the interpreter will be compiled to a stand-alone executable that can be passed a \emph{bf} file on the command line.

\subsection{Interpreter State}

The really interesting part of all this is, of course, the interpreter logic itself. I chose to implement the interpreter as a single function that manipulates a tuple representing execution state. Its type is defined as follows:

\begin{code}
type InterpreterState = ([Int],Int,[Char],[[Char]],[Char],[Char])
\end{code}

This makes the name \textit{InterpreterState} a synonym for a 6-tuple with the given elements: a list of integral numbers, a single integral number, a list of characters, a list of lists of characters, and, finally, two more lists of characters. (In Haskell, names of types begin with upper-case characters, and a list type is denoted by putting square brackets around another type.)

The six elements in the \textit{InterpreterState} tuple have the following meanings:\begin{itemize}
\item\textit{[Int]}: this is the memory of the \emph{bf} interpreter. It can be thought of as an array of numbers.
\item\textit{Int}: the pointer for reading from and writing to memory.
\item\textit{[Char]}: the code to be run by the interpreter. This is a string with all the \emph{bf} characters (and also others, which are ignored). Haskell does have a type \textit{String}, which is a synonym for \textit{[Char]}, but I want to think of \emph{bf} code as a sequence of single characters, so I chose this representation.
\item\textit{[[Char]]}: a list of code sequences; actually, continuations to be used for \emph{bf}'s loop constructs. See below for details.
\item\textit{[Char]} (twice): the input consumed and output generated by the running program. Note that input and output are part of the interpreter's state: I have chosen a side-effect free way of implementing it. In part, this is because I have not yet fully grasped the ways of dealing with side effects such as output being generated by an interpreter while it is at work; but it is also because a pure solution, given the nature of Haskell, seemed more idiomatic.
\end{itemize}

\subsection{The Interpreter Function}

Defining the type signature of the \textit{interpret} function is easy, as it simply transforms interpreter state:

\begin{code}
interpret :: InterpreterState -> InterpreterState
\end{code}

This code states that the \textit{interpret} function's type signature (\textit{::}) implies that this function accepts one argument of type \textit{InterpreterState} and returns a value of the same type.

\subsection{Controlled Termination}

Here is the first piece of actual interpreter code:

\begin{code}
interpret (m, p, [], cts, i, o) = (m, p, [], cts, i, o)
\end{code}

Haskell supports pattern matching; i.\,e., one can give ``examples'' for values passed to a function, and describe the function's behaviour based on the example. The above definition means that whenever \textit{interpret} is applied to an \textit{InterpreterState} tuple with elements 1, 2, 4, 5, and 6 that can be named \textit{m}, \textit{p}, \textit{cts}, \textit{i}, and \textit{o}, and an empty list in position 3, that same tuple is the value of the function.

In other words, when arbitrary values are passed in the interpreter state, but the third element (the code array of characters) is empty, then the passed interpreter state is the final state of this run. In yet other words, if there is no more code to execute, the interpreter terminates.

\subsection{Memory Pointer Control}

Here is how the read/write pointer is manipulated by executing the \texttt{>} and \texttt{<} \emph{bf} commands:

\begin{code}
interpret (m, p, '>':cs, cts, i, o) = interpret (m, p+1, cs, cts, i, o)
interpret (m, p, '<':cs, cts, i, o) = interpret (m, p-1, cs, cts, i, o)
\end{code}

Again, the \textit{interpret} function is partially specified by means of patterns and the reactions to them. Most of the patterns on the left-hand side of the equals sign are identical to the pattern given above for termination. The difference lies in one place, namely the third element of the interpreter state tuple, which represents the \emph{bf} code to be executed.

For example, in the first pointer manipulation rule, the code pattern is \textit{\texttt{'>'}:cs}. Recall that the code is a list of characters (\textit{[Char]}). In Haskell, \textit{x:xs} matches a list of items in to its head and its tail, binding the head element to \textit{x} and the tail list to \textit{xs}.

In this particular case, the head is not bound to a name, but matched against the character literal \texttt{>}, meaning that this rule matches if the code list consists of a \texttt{>} at the beginning, and arbitrary other characters. In other words, when the interpreter encounters a \texttt{>} \emph{bf} instruction, this part of the \textit{interpreter} function will be applied.

What happens on the right-hand side of the rule is that \textit{interpreter} calls itself recursively, passing along an updated interpreter state tuple. In fact, the tuple is identical to the matched argument, with two exceptions: the memory pointer, \textit{p}, is incremented by one, and the code list is reduced by the command that the interpreter has just consumed. The \texttt{<} command is treated analogously.

The fact that the \textit{interpret} function calls itself recursively may feel awkward at first, because it looks as if, for very long \emph{bf} programs, very deep call stacks would occur, probably leading to problems as maximum stack depth is exceeded. In fact, recursive function application is a very common idiom in functional programming languages where no loop control structures exist, and their run-time environments and compilers usually circumvent the stack depth problems by applying tail recursion optimisation.

In case the recursive application of itself is the last part of a function, a compiler will not generate a function call, but, basically, a jump to the beginning of the code with the parameters replaced. This allows for arbitrary recursion depths without any noteworthy stack effects.

\subsection{Manipulating Memory Contents}

The \emph{bf} \texttt{+} and \texttt{-} commands are responsible for incrementing and decrementing the value stored in the current memory location:

\begin{code}
interpret (m, p, '+':cs, cts, i, o) = interpret (incr m p, p, cs, cts, i, o)
interpret (m, p, '-':cs, cts, i, o) = interpret (decr m p, p, cs, cts, i, o)
\end{code}

Note how the patterns on the left-hand side work precisely as seen above. On the right-hand side, the same structure can be observed as well, only the interpreter state is now modified in the first position, implying an update in memory. The code for the \texttt{+} and \texttt{-} commands makes use of two auxiliary functions named \textit{incr} and \textit{decr}, which accept the memory and current pointer as arguments and appear to replace the memory with a new one. These functions will be explained below. For now, just accept that they increment and decrement the value stored in \textit{m} at position \textit{p} by one.

\subsection{I/O}

Output and input are next, represented by \texttt{.} and \texttt{,} in \emph{bf}. Let us consider the output part first:

\begin{code}
interpret (m, p, '.':cs, cts, i, o) =
  interpret (m, p, cs, cts, i, o ++ [chr (m !! p)])
\end{code}

Output in \emph{bf} means that the value at the current memory position is to be printed. In this purely functional interpreter implementation, it means that the character to be printed has to be appended to the output part of the interpreter state tuple. This is exactly what this rule does.

The \textit{m !! p} expression obtains the value at position \textit{p} from the list \textit{m}. This value (recall it is an \textit{Int}) has to be turned into a \textit{Char} to be appended to the \textit{[Char]} list representing output. The \textit{chr} function achieves this conversion.

This expression is wrapped in square brackets to turn it into a one-element list. This is necessary because the \textit{++} list concatenation function expects lists on both sides. In this case, the already existing output list \textit{o} is extended with the one-element list containing the single character obtained from memory.

Implementing input requires a bit more effort:

\begin{code}
interpret (m, p, ',':cs, cts, [], o) = (m, p, cs, cts, [], o)

interpret (m, p, ',':cs, cts, j:i, o) =
  interpret (putm (ord j) m p, p, cs, cts, i, o)
\end{code}

Note that there are \emph{two} rules for matching the \texttt{,} command. They differ in the last-but-one entry in the interpreter state pattern.

The first rule matches \texttt{,} and an empty list, implying that there is no more input to consume. As this would lead to inconsistent state in the running program, the interpreter bails out in such a case, returning the state tuple as is. This behaviour effectively leads to interpreter termination, as above for the case where no more code is available to execute.

The second rule matches \texttt{,} and \textit{j:i}, separating input into one single character \textit{j} and the remaining input \textit{i}. That is, input is consumed one character at a time, each time a \texttt{,} command is interpreted. The semantics of this command is to store the ASCII value of the input character at the current memory location. This is done by means of applying the auxiliary \textit{putm} function (see below) to the ASCII value, which is obtained using the \textit{ord} function, as well as \textit{m} and \textit{p}.

\subsection{Loops}

Loops are the most interesting construct in \emph{bf}. To recapitulate, a \texttt{[} command checks whether the current memory position holds a zero value. If so, it jumps to the matching \texttt{]} and continues execution there. In case the value is not zero, execution proceeds as usual. The \texttt{]} command simply jumps back to the matching \texttt{[}, starting the loop over.

The \texttt{[} loop command is implemented as follows:

\begin{code}
interpret (m, p, '[':cs, cts, i, o) =
  if 0 == m !! p
  then interpret (m, p, continue cs, cts, i, o)
  else interpret (m, p, cs, ('[':cs):cts, i, o)
  where continue cs = chelp 0 cs
          where
            chelp _ [] = []
            chelp i (r:rest)
              | r == '['           = chelp (i+1) rest
              | r == ']' && i > 0  = chelp (i-1) rest
              | r == ']' && i == 0 = rest
              | otherwise          = chelp i rest
\end{code}

The rule for \texttt{[} checks the value at position \textit{p} in the memory using the familiar \textit{!!} function. If it is zero, the interpreter state is changed in the code position, replacing the code to be executed with the result of applying the \textit{continue} function to the remaining code stored in \textit{cs}.

The job of the \textit{continue} function (conveniently defined local to this particular rule in a \textit{where} clause) is to find a matching \texttt{]} for the \texttt{[} that was just consumed by the corresponding interpreter rule, and to return all the code after that matching \texttt{]}. This is the code where execution should continue after the loop terminates. In the process of finding the correct position, matching pairs of square brackets must not be ignored; it is not sufficient to simply find the first \texttt{]}.

Since both the argument to and result obtained from applying \textit{continue} are \emph{bf} code, its type signature is \textit{[Char] $\rightarrow$ [Char]}. The function applies a helper function, \textit{chelp}, which maintains a bracket pair counter (initially, it has the value 0). The helper function is conveniently defined local to the \textit{continue} function in a \textit{where} clause.

The helper function is once again defined using patterns. Its first rule matches an empty list of characters and ignores the counter, which is expressed by the underscore in the position where the counter argument would have to be passed. Ignoring an argument means it is not bound to any name on the right-hand side of the function definition. In case \textit{chelp} matches empty input, it simply returns an empty list: no matching \texttt{]} could be found.

All other cases are processed by the second rule, where the counter value is bound to \textit{i}, and the code character list is split into the first element \textit{r} and the remaining characters, which are contained in the list \textit{rest}.

The \textit{chelp} function needs to react in different ways to different input characters, and it does so using \emph{guards}, which are expressed as Boolean expressions preceded by a pipe symbol. The first of the guards matches if the head character in the code array is a \texttt{[}, and it reacts by recursively applying \textit{chelp} with the counter increased by one. This means that a nested pair of square brackets needs to be found before the matching \texttt{]} can be identified.

Matching a \texttt{]} can have one of two consequences. On the one hand, if the counter value is greater than zero, a nested pair has been matched, so \textit{chelp} is applied with a decreased counter. On the other hand, if the counter value is zero, the desired matching \texttt{]} has been found, and the remaining code is the code to be executed---so it can be returned.

The last guard, denoted by \textit{otherwise} (which is always true), works for all other characters that deserve no special treatment in the course of matching square brackets. In this case, \textit{chelp} is simply applied to the remaining code without modifying the counter.

To summarise, if the interpreter executes a \texttt{[} command \emph{and} the current memory location holds a zero value, the code with whose execution the interpreter must continue after loop termination is obtained using \textit{continue}, and execution proceeds there.

In case the current memory location does not contain a zero value, the interpreter continues execution as usual with the code contained in \textit{cs}. Note, however, that the fourth position of the interpreter state tuple is changed: it is replaced with the result of the expression \textit{(\texttt{'['}:cs):cts}.

As mentioned above, the \textit{x:xs} construct represents a list with head element \textit{x} and tail list \textit{xs}. The construct can also be used to \emph{prepend} an element to a list. Here, an element is prepended to the \textit{cts} list, namely the result of prepending \texttt{[} to the remaining code. In other words, it is precisely the code that the interpreter rule matched that is restored (by prepending the \texttt{[} consumed by pattern matching) and prepended to the \textit{cts} list.

The effect of this becomes clear after taking a look at how the interpreter deals with \emph{bf}'s \texttt{]} command:

\begin{code}
interpret (m, p, ']':cs, next:cts, i, o) = interpret (m, p, next, cts, i, o)
\end{code}

The pattern separates the fourth element of the interpreter state tuple into the \textit{next} and \textit{cts} parts, and the recursive application of \textit{interpret} uses \textit{next} as the code to be executed. One can think of the elements of the \textit{[[Char]]} item in the interpreter state as \emph{continuations}: sequences of code that are stored for later execution.\footnote{I am a bit unsure whether it is fair to call these ``continuations''. Opinions?}

Now, the way this \emph{bf} interpreter deals with loops can be wrapped up. In a nutshell, the \texttt{[} command, if the loop body needs to be executed, stores the entire code, starting with the respective loop, as a continuation in the interpreter state. At the end of the loop, \texttt{]} retrieves the continuation from the state tuple and establishes it as the code to be executed. Recall that the continuation contains the \emph{complete} code until the end of the program.

\subsection{The Rest Is Comment}

There is one final rule in the \textit{interpret} function that needs to be covered:

\begin{code}
interpret (m, p, _:cs, cts, i, o) = interpret (m, p, cs, cts, i, o)
\end{code}

The pattern matches \emph{any} character not matched by any of the other rules and \emph{ignores} it (underscore). Recursive application of \textit{interpret} simply uses the remaining code (\textit{cs}). The purpose of this rule is to silently ignore all characters that are not part of the \emph{bf} syntax.

\section{Auxiliary Functions}

Above, three auxiliary functions were mentioned, namely \textit{incr}, \textit{decr}, and \textit{putm}. Their type signatures are as follows:

\begin{code}
incr :: [Int] -> Int -> [Int]
decr :: [Int] -> Int -> [Int]
putm :: Int -> [Int] -> Int -> [Int]
\end{code}

Both \textit{incr} and \textit{decr} accept a list of integers (the memory) and an integer (the pointer) and return the updated memory. The \textit{putm} function accepts one more \textit{Int} argument, namely the value to be written to the memory position denoted by the pointer.

These functions all have one thing in common: they are supposed to update a given memory position in some way. The structure of these three operations is the same: the correct position in the \textit{Int} list that is memory must be identified, the modification must be applied, and the updated list must be returned. The point of variation in this is the way the modification is applied. This calls for using higher-order functions to avoid repetition.

Here is a function called \textit{updateAt} that provides the required framework:

\begin{code}
updateAt :: (Int -> Int) -> [Int] -> Int -> [Int]
updateAt f m p = left ++ (f v):right
                 where (left,v:right) = splitAt p m
\end{code}

Looking at the type signature, it is apparent that \textit{updateAt} accepts a function mapping integers to integers (this is the function used to manipulate memory contents---the variation point mentioned above), a list of integers (the memory), and an integer (the pointer). It answers the updated memory.

The function concatenates two lists, namely \textit{left} and the result of prepending the result of applying \textit{f} to some value \textit{v} to a list named \textit{right}. These are defined in the \textit{where} clause, which applies the standard \textit{splitAt} function to the memory list. This function accepts an integer \textit{k} and a list and returns a tuple with two elements, both of which are lists. The first list in the tuple contains the first \textit{k} elements of the original list, and the second, the remaining elements.

In the \textit{where} clause, pattern matching is used to directly bind the elements of the tuple (or parts thereof) to the three names required in \textit{updateAt}. The \textit{left} part of the list contains all the elements up to (but not including) the element at the position that needs to be updated. The second part of the tuple returned from \textit{splitAt} is conveniently separated into the element that needs to be updated (\textit{v}) and the remainder of the list (\textit{right}).

It is now easy to see how \textit{updateAt} works: it leaves the \textit{left} and \textit{right} parts of the list untouched, applies the update function \textit{f} to the element to update, and returns a newly concatenated list containing all the original elements (and the updated one) in the correct order.

Implementing the three auxiliary functions is now easy:

\begin{code}
incr = updateAt (\v -> v + 1)
decr = updateAt (\v -> v - 1)
putm c = updateAt (\_ -> c)
\end{code}

All three functions use \textit{updateAt}, passing a \emph{lambda expression} as the required manipulation function. In the case of \textit{incr} and \textit{decr}, the lambda expression simply increments or decrements its argument. In the case of \textit{putm}, the argument is ignored (underscore) and replaced by \textit{c}, which is the value to be written to the memory location in question.

It may seem strange that no full argument lists are given on the left-hand sides of these three definitions. They make use of \emph{currying}, which allows for so-to-speak partially applying functions. For instance, \textit{incr} recurs to \textit{updateAt} but passes only one argument, namely the first one required by \textit{updateAt} (a function mapping \textit{Int} to \textit{Int}).

Recall \textit{updateAt}'s signature: \textit{(Int $\rightarrow$ Int) $\rightarrow$ [Int] $\rightarrow$ Int $\rightarrow$ [Int]}. Partially applying a function in Haskell yields another function. In this case, partially applying \textit{updateAt} by passing only the first argument (which is a lambda expression with the type signature \textit{(Int $\rightarrow$ Int)}) will reduce the type signature by the applied-to arguments, yielding a function with the type signature \textit{[Int] $\rightarrow$ Int $\rightarrow$ [Int]}. This is precisely the signature of \textit{incr}.

The remaining arguments of \textit{incr} do not have to be mentioned in its definition, as their names do not play a substantial role in its definition. To illustrate this, here is a definition of \textit{incr} with all the arguments: \textit{incr m p = updateAt ($\lambda$v $\rightarrow$ v+1) m p}. The \textit{m} and \textit{p} arguments are merely repeated on the right-hand side. Currying allows for omitting them, abbreviating function definition and reducing it to the bare minimum.

\section{Running \emph{bf} Code}

The interpreter is complete, now we need to be able to run some \emph{bf} code. The \textit{run} function is defined as follows:

\begin{code}
run :: [Char] -> [Char] -> [Char]
run code input = output
  where
    (_, _, _, _, _, output) = interpret (mem, 0, code, [], input, [])
    mem                     = take 32768 (repeat 0)
\end{code}

It accepts a code string and some input, and returns the output generated by running the interpreter. The \textit{output} variable is bound to the last element of the interpreter state tuple returned from applying the \textit{interpret} function to a start configuration. Note how all other elements of the final state are ignored.

The start configuration is assembled from an initial memory and pointer, the code, an empty list of continuations, the input, and an initially empty output list. The memory is initialised to 32\,kB filled with zeros. The \textit{repeat} function returns an infinite list containing elements with the same value, which is passed to the function. Since Haskell is a lazy language where all expressions are not evaluated until their results are actually needed, taking the first 32,768 elements from this infinite list will not exhaust memory.

Now it is possible to run \emph{bf} programs in a simple fashion, e.\,g., like this: \verb!run "+++." ""!. Unfortunately, \emph{bf} programs that do something useful, such as printing a hello world message, tend to be lengthy. It is favourable to invoke the interpreter and have it run the contents of a file. The function required to achieve this goal can look like this:

\begin{code}
runFile :: FilePath -> [Char] -> IO [Char]
runFile file input = do
                       code <- readFile file
                       return (run code input)
\end{code}

It accepts a \textit{FilePath} (a string) and the input to be passed to the program and returns a value of the type \textit{IO [Char]}. This means that the function has I/O side effects (\textit{IO} is actually a monad, and the result of \textit{runFile} is a list of characters wrapped in the \textit{IO} monad).

The function first extracts all contents from the passed file and stores them in \textit{code} as a string. It then applies the aforementioned \textit{run} function to the code and input and returns the result.

\section{Standalone Binaries}

To be able to create a native executable of the \emph{bf} interpreter, a main function is required---not unlike in a C program. Here it is:

\begin{code}
main = do
         file:_ <- getArgs
         code <- readFile file
         interact (run code)
\end{code}

It retrieves all command line arguments using \textit{getArgs} and discards all but the first element of the resulting list, binding it to \textit{file}. The code to be executed is then read from the file.

Next, the \textit{interact} function is applied. Note how \textit{run} is not applied to code and input, but to code only. Again, currying is used here: internally, \textit{interact} passes standard input as the next argument to the partially applied \textit{run} function. The result of \textit{run} is passed to standard output.

Creating a standalone executable from the source file of this PDF (recall that literate programming is being used here) is as easy as this: \verb!ghc --make brainfuck.lhs!.

\end{document}

